---
title: "Brutus (HTB Sherlock) — Linux Auth Triage Lab"
description: "staying simple: how i solved HTB’s ‘Brutus’ with basic grep/awk, a quick wtmp vs auth.log check, light TZ sanity, and a tiny MITRE mapping."
date: "2025-09-20"
slug: "brutus-htb-sherlock"
tags: ["labs", "linux", "auth.log", "wtmp", "ssh", "grep", "awk", "timezone", "mitre"]
order: 2
---

> **disclaimer** — training-room artifacts only. sensitive values are **masked**. this post documents **what i actually did**, not an idealized regex fest.

## briefing

- **room:** Sherlock → Brutus (Hack The Box)  
- **scenario (short):** We'll explore a scenario where a Confluence server was brute-forced via its SSH service. After gaining access to the server, the attacker performed additional activities, which we can track using auth.log.   
- **artifacts:** `auth.log` (plaintext auth events) and `wtmp` (binary login history, read with `last`).

## plan of attack (simple)

1) skim `auth.log` for sshd activity and rough time window.  
2) count **failed** attempts by IP and by username.  
3) list **successful** logins and pair **user ↔ source IP**.  
4) confirm real sessions via `wtmp` using `last -f`.  
5) if answers need UTC, print with `TZ=UTC` for consistency.  
6) answer the prompts and map to MITRE.

## tools used

- `grep -i` (case-insensitive), `grep -o` (print only match) **sparingly**  
- `awk` for simple field grabs (no fancy regex)  
- `sort | uniq -c | sort -nr` for counts  
- `last -f wtmp` for session history  
- `TZ=UTC` to normalize timestamps when needed

---

## step-by-step (sanitized)

### 1) quick skim

```bash
# rough earliest/latest sshd lines
grep -i 'sshd' auth.log | head
grep -i 'sshd' auth.log | tail
```

### 2) failed password noise

**top talker IPs (simple)**  
*(kept it minimal; optional IP regex shown after)*
```bash
grep -i 'failed password' auth.log | awk '{print $NF}' | sort | uniq -c | sort -nr | head
```

**top usernames that were tried**  
```bash
grep -i 'failed password' auth.log | awk '{for(i=1;i<=NF;i++) if($i=="for"){print $(i+1)}}' | sort | uniq -c | sort -nr | head
```

> alt (what i tested while learning):  
> `awk '{print $5}' auth.log | sed 's/[\[\:].*//g' | sort | uniq -c | sort -n`  
> idea: grab a field, strip bracket/colon clutter, then count.

**optional** (stricter IP extraction — not required for the solve)
```bash
grep -i 'failed password' auth.log | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}' | sort | uniq -c | sort -nr | head
```

### 3) successful logins to investigate

```bash
# list accepted auths (password or key)
grep -i 'accepted' auth.log
```

```bash
# quick user ↔ ip table (common Debian/Ubuntu sshd format)
grep -i 'accepted' auth.log | awk '{user=$9; ip=$NF; printf "%-20s %s\n", user, ip}' | sort | uniq -c | sort -nr
```

> tip: in many lines shaped like `Accepted password for username from 1.2.3.4 ...`, `$9` is the username and `$NF` (last field) is the source IP.

### 4) confirm sessions via wtmp

```bash
last -f wtmp | head -20
```

Cross-check that a listed **Accepted** login aligns with an actual **session** in `last` around the same time.

### 5) timezone sanity (when the prompt wants UTC)

```bash
TZ=UTC last -f wtmp | head -10
```

---

## answers (masked to match my run)

- **user with successful auth:** `username_masked`  
- **noisiest failed IP:** `203.101.190.9`  
- **first successful auth (UTC):** `2025-09-** **:**` *(normalized with `TZ=UTC`)*

*(replace with your exact outputs; keep pii minimal.)*

---

## commands i actually leaned on (no “extensive regex”)

```bash
# case-insensitive search
grep -i 'failed password' auth.log | head

# count occurrences by last column (often the source IP)
grep -i 'failed password' auth.log | awk '{print $NF}' | sort | uniq -c | sort -nr | head

# extract the username that follows the word 'for'
grep -i 'failed password' auth.log | awk '{for(i=1;i<=NF;i++) if($i=="for"){print $(i+1)}}' | sort | uniq -c | sort -nr | head

# list successes and show user ↔ ip
grep -i 'accepted' auth.log | awk '{user=$9; ip=$NF; printf "%-20s %s\n", user, ip}' | sort | uniq -c | sort -nr

# wtmp (binary) session history
last -f wtmp | head
```

---

## mitre mapping (minimal & relevant)

- **Credential Access / Brute Force** — `T1110` (wide username/IP spray with many failures)  
- **Valid Accounts** — `T1078` (a real login succeeds with a legitimate account)

---

## lessons learned

- `auth.log` (plaintext events) vs `wtmp` (binary session DB → read with `last`).  
- `grep -i` + simple `awk` is enough for fast triage; save complex regex for later.  
- `sort | uniq -c | sort -nr` is the counting backbone.  
- set `TZ=UTC` on commands when answers must be compared across systems/timezones.

---